
%------------------------ Start chapter 3 -------------
\cchapter{روش حل مسئله}
\pagebreak

\section{مقدمه}
 این پروژه در دو بخش کلی پیش‌پردازش در سمت سخت‌افزار و پردازش در سرور انجام شده‌است. در بخش اول، تعدادی پردازش اولیه بر روی داده‌های خام ضربان قلب انجام می‌شود. این بخش یک بستر پیاده شده بر روی سخت‌افزار است که برای کامل شدن باید به یک سنسور ضربان قلب متصل شود. این بخش همراه بیمار خواهد بود و پردازش‌های ساده‌ی اولیه را بر روی سیگنال نوار قلب انجام خواهد داد و نتایج آن به سرور ارسال می‌شود.  پردازش‌های پیچیده‌تر برای تشخیص آریتمی بر عهده‌ی سرور خواهد بود. در سرور یک الگوریتم دسته‌بندی بر روی داده‌ا انجام شده و کلاس آریتمی آن‌ها تشخیص داده می‌شود.

\section{عملیات پیش‌پردازش بر روی سخت‌افزار} 
در این بخش عملیات پیش‌پردازش با هدف تشخیص ترکیب QRS در هر ضربان قلب بر روی سیگنال دیجیتال ضربان قلب اجرا می‌شود. خروجی این عملیات، موقعیت زمانی قله‌ی R در ترکیب QRS هر ضربان است که در پردازش‌های آینده برای تشخیص آریتمی آن ضربان مورد استفاده قرار می‌گیرد.

	\subsection{مراحل تشخیص QRS}
	
	پیش از ورود سیگنال نوار قلب به ماژول پیش‌پردازش، نوار قلب خام گرفته‌شده از بیمار  از یک مبدل آنالوگ به دیجیتال\LTRfootnote{ADC} عبور کرده و با نرخ نمونه‌برداری\LTRfootnote{Sampling rate} معینی به سیگنال دیجیتال تبدیل می‌شود. مقدار این نرخ نمونه‌برداری در برخی مراحل پیش‌پردازش اهمیت دارد. 
پس از دیجیتال شدن، سیگنال وارد ماژولی که برای تشخیص \lr{QRS} طراحی کرده‌ایم می‌شود. در ادامه به مراحل اصلی طی‌شده در این بخش می‌پردازیم.
		\subsubsection{حذف نویز سیگنال به کمک فیلتر میان‌گذر}
		اولین مرحله در تشخیص \lr{QRS} حذف نویز سیگنال نوار قلب است. در حین ثبت ضربان قلب، منابع مختلفی از نویز در سیگنال اختلال ایجاد می‌کنند.در یک سیگنال ECG به طور معمول نویزهای فرکانس پایینی ناشی از baseline wander وجود دارد. این نویزها به علت حرکت الکترودها بر روی پوست و همین طور اعمالی چون حرکات و تنفس بیمار به وجود می‌آیند. انقباض ماهیچه‌های اطراف قلب نیز یکی دیگر از منابع نویز است. این انقباضات توسط الکترودها ثبت شده و در نوار قلب نویزهای فرکانس بالایی ایجاد می‌کنند.\cite{Joshi2013}
		
		با توجه به نویزهای معمول، محدوده‌ی فرکانسی مطلوب برای بیشینه‌کردن انرژی QRS و کمینه‌کردن انرژی نویز، ۵ تا ۱۵ هرتز تشخیص داده شده‌است.\cite{Pan1985} به منظور نگه‌داشتن این بازه‌ی فرکانسی و حذف فرکانس‌های بالا و پایین آن، سیگنال دیجیتال از یک فیلتر میان‌گذر عبور داده می‌شود. این فیلتر متشکل از یک فیلتر پایین‌گذر و یک فیلتر بالاگذر متوالی است. هر دوی این فیلترها به صورت نرم‌افزاری پیاده‌سازی شده‌اند. هر دوی این فیلترها، IIR بوده و زمان‌گسسته هستند. 
تابع تبدیل فیلتر پایین‌گذر را در معادله‌ی \ref{eq:lowpassTr} مشاهده می‌کنیم.

\begin{equation}
	H(z) = \frac{{(1-z^{-6})}^2}{{(1-z^{-1})}^2}
\label{eq:lowpassTr}
\end{equation}
	
	معادله‌ی تفاضلی این فیلتر به صورت معادله‌ی \ref{eq:lowpassDE} در خواهد آمد.
	
\begin{equation}
	y(nT) = 2y(nT-T) - y(nT-2T) + x(nT) - 2x(nT-6T) + x(nT-12T) 
\label{eq:lowpassDE}
\end{equation}
فرکانس قطع این فیلتر پایین‌گذر ۱۱ هرتز و gain آن ۳۶ است. یک فیلتر بالاگذر به صورت سری با این فیلتر قرار می‌گیرد که تابع تبدیل آن به صورت معادله‌ی \ref{eq:highpassTr} است.
\begin{equation}
	H(z) = \frac{{(-1+32z^{-16}+z^{-32})}}{{(1+z^{-1})}}
\label{eq:highpassTr}
\end{equation}
که معادله‌ی تفاضلی آن به صورت معادله‌ی \ref{eq:highpassDE} خواهد بود.
 \begin{equation}
	y(nT) = 32x(nT-16T) - [y(nT-T) + x(nT) - x(nT-32T)]
\label{eq:highpassDE}
\end{equation}
این فیلتر فرکانس‌های بالای ۵ هرتز را عبور می‌دهد و gain آن ۳۲ است. از توالی این دو فیلتر، فیلتر میان‌گذری به دست می‌آید که فرکانس‌های ۵ تا۱۱ هرتز را عبور می‌دهد که به هدف ما برای کاهش نویز نزدیک است. 

\subsubsection{مشتق‌گیر}
پس از اعمال فیلترها، عمل مشتق‌گیری بر روی سیگنال انجام می‌شود. مشتق‌گیری از سیگنال، اطلاعاتی در مورد شیب آن در بازه‌ی QRS فراهم می‌کند. تابع انتقال این فیلتر به صورت معادله‌ی \ref{eq:derivativeTr} است و معادله‌ی تفاضلی آن به صورت رابطه‌ی \ref{eq:derivativeDE} می‌آید.

\begin{equation}
	H(z) = \frac{(-z^{-2}-2z^{-1}+2z+z^2)}{8T}
\label{eq:derivativeTr}
\end{equation}
	
\begin{equation}
	y(nT) = \frac{-x(nT-2T)-2x(nT-T)+2x(nT+T)+x(nT+2T)}{8T}
\label{eq:derivativeDE}
\end{equation}

\subsubsection{مجذورکننده}
پس از مشتق‌گیری، مجذور سیگنال به صورت نقطه به نقطه به دست می‌آید. معادله‌ی تفاضلی فیلتر در این بخش به صورت معادله‌ی \ref{eq:square} است. اعمال این فیلتر بر روی خروجی مشتق‌گیر، باعث می‌شود تمامی نقاط سیگنال مثبت شده و به دلیل انجام عمل مربع‌کردن، فواصل نقاط گسسته‌ی سیگنال تشدید شود.

\begin{equation}
	y(nT) = [x(nT)]^2
\label{eq:derivativeDE}
\end{equation}

\subsubsection{انتگرال‌گیر با پنجره‌ی لغزان}
در این مرحله سیگنال مربع‌شده وارد یک انتگرال‌گیر می‌شود. هدف از این کار، به دست آوردن اطلاعاتی در مورد شکل موج سیگنال، علاوه بر اطلاعات مربوط به شیب موج R است که در مراحل قبل به دست آمد. معادله‌ی تفاضلی این انتگرال‌گیر به صورت معادله‌ی \ref{eq:integrator} است.

\begin{equation}
	y(nT) = \frac{x(nT-(N-1)T) + x(nT-(N-2)T+...+x(nT))}{N}
\label{eq:integrator}
\end{equation}

که در آن N تعداد نمونه‌ها در طول پنجره‌ی انتگرال‌گیر است. $N$ به صورت تجربی به دست می‌آید و در تشخیص نهایی \lr{R} اهمیت زیادی دارد. به طور معمول $N$ باید تقریبا به اندازه‌ی عریض‌ترین بازه‌ی \lr{QRS} باشد. در صورتی که پنجره بیش از حد عریض باشد، در هنگام انتگرال‌گیری، شکل موج \lr{QRS} با موج \lr{T} ترکیب می‌شود. اگر پنجره بیش از حد کوتاه باشد، کل بازه‌ی \lr{QRS} را در بر نمی‌گیرد و در این بازه تعداد زیادی قله تولید خواهد شد. این مقدار به طور تجربی به دست آمده و با نرخ نمونه‌برداری ارتباط دارد. در این پروژه طول پنجره ۷۰ در نظر گرفته شده‌است.

\subsubsection{تعیین موقعیت قله‌های R با کمک مقدارهای آستانه}

موج \lr{QRS} هم‌زمان با لبه‌ی بالارونده‌ی انتگرال‌گیر رخ می‌دهد، و طول بازه‌ی این لبه برابر با طول بازه‌ی \lr{QRS} است. به این ترتیب، می‌توان موقعیت زمانی \lr{QRS} را از روی جایگاه لبه‌ی بالارونده تعیین کرد. با استفاده از این اطلاعات، و همین طور اطلاعات مربوط به شیب منحنی \lr{QRS} در این بازه، می‌توان نقطه‌ی ثابتی را به عنوان موقعیت قله‌ی \lr{R} به دست آورد.
برای تعیین درست موقعیت قله‌ی \lr{R} تعدادی ولتاژ آستانه\LTRfootnote{Threshold}اعمال می‌شوند و به نسبت بالاتر یا پایین‌تر بودن ولتاژ هر نمونه از آن‌ها، وجود یا عدم وجود قله تشخیص داده می‌شود. این آستانه‌ها با گذشت زمان با نویز تطبیق می‌یابند. در مجموع دو سری ولتاژ آستانه داریم که هر کدام شامل دو آستانه هستند. در هر یک از این دو سری، آستانه‌ی بالاتر برای تحلیل اولیه‌ی سیگنال استفاده می‌شود، و در صورتی که در یک بازه‌ی زمانی مشخص \lr{QRS} ای تشخیص داده نشده باشد، لازم است در این بازه از تکنیک جستجوی برگشتی\LTRfootnote{Search-back} استفاده شود. در این تکنیک در این بازه‌ی زمانی  از آستانه‌های پایین‌تر برای تشخیص \lr{QRS} استفاده می‌شود. روابط این آستانه‌ها در معادله‌ی \ref{eq:thresholds} مشاهده می‌شوند. در این روابط، $PEAK1$ بالاترین ولتاژ سیگنال به طور کلی، $SPKI$ تخمین جاری از بالاترین ولتاژ سیگنال و $NPKI$ تخمین جاری از بالاترین ولتاژ نویز در هر لحظه است. همچنین $THRESHOLD I1$ اولین مقدار آستانه‌ی اعمال‌شده بر روی سیگنال انتگرال‌گیری‌شده و $THRESHOLD I2$ دومین مقدار آستانه و نصف مقدار آستانه‌ی اول است.

\begin{align}
\begin{split}
	& SPKI = 0.125 PEAKI + 0.875 SPKI\\
	& NPKI = 0.125 PEAKI + 0.875 NPKI\\
	& THRESHOLD I1 = NPKI + 0.25(SPKI - NPKI)\\
	& THRESHOLD I2 = 0.5 THRESHOLD I1\\
\end{split}
\label{eq:integrator}
\end{align}
برای این که یک نمونه به عنوان قله‌ی \lr{R} تشخیص داده شود، باید مقداری بالاتر از $THRESHOLD I1$ داشته باشد. در صورتی که یک قله‌ی \lr{R} در فرایند جستجوی برگشتی تشخیص داده شود، مقدار $SPK_I$ به صورت رابطه‌ی \ref{eq:thresholdSPKI} به‌روز خواهد شد. 
\begin{equation}
	SPKI = 0.25 PEAKI + 0.75 SPKI
\label{eq:thresholdSPKI}
\end{equation}

	\subsection{پیاده‌سازی الگوریتم تشخیص QRS بر روی بستر سخت‌افزاری}
ورودی این بخش، سیگنال دیجیتال دریافت شده از سنسور ضربان قلب است. نحوه‌ی تولید این سیگنال و نوع سنسور به‌کاررفته برای آن کاملا به کاربرد بستگی داشته و در این پروژه تاکیدی بر روی آن نیست. محاسبات انجام‌شده در الگوریتم تشخیص \lr{QRS}، به مقدار نرخ نمونه‌برداری سیگنال ضربان قلب وابسته است. پارامترهای الگوریتم پیاده‌سازی شده در این بخش، برای نرخ نمونه‌برداری ۳۶۰ نمونه بر ثانیه بهینه شده‌اند و از این روی، لازم است نرخ نمونه‌برداری سیگنال دیجیتال ورودی، مساوی با ۳۶۰ یا نزدیک به آن باشد.

خروجی این بخش، موقعیت زمانی قله‌ی \lr{R} در هر یک از بازه‌های \lr{QRS} تشخیص‌داده‌شده در ضربان قلب است. به بیان دیگر، الگوریتم برخی از نمونه‌ها در سیگنال را به عنوان قله‌ی \lr{R} تشخیص داده و شماره‌ی آن نمونه را به عنوان خروجی برمی‌گرداند. این مقادیر باید برای انجام پردازش‌های آینده به سرور ارسال شوند. از آن‌جا که از کل سیستم انتظار بی‌درنگ‌بودن داریم، علاوه بر تشخیص بی‌درنگ \lr{QRS} لازم است دریافت داد‌ه‌های خام از حسگر و همین‌طور فرستادن قله‌های lr{R} تشخیص‌داده‌شده به سرور نیز به صورت بی‌درنگ و در حین تشخیص \lr{QRS} انجام شود. به بیان بهتر، در چنین کاربردی انجام تشخیص \lr{QRS} بر روی ضربان قلب به طور کامل و سپس فرستادن تمامی Rهای تشخیص‌داده‌شده به سرور قابل قبول نخواهد بود.
کارهای انجام‌شده در این بخش را می‌توان در قالب موارد زیر بیان کرد. 
\subsubsection{دریافت داده‌های خام جدید از حس‌گر}
در این بخش، هدف بر این است که رفتار یک حس‌گر دیجیتال ضربان قلب با نرخ نمونه‌برداری ۳۶۰ نمونه بر ثانیه شبیه‌سازی شود. بهترین راه‌حل برای این کار، استفاده از ارتباط سریال بین ماژول و یک رایانه (به جای حس‌گر) تشخیص داده شد. با فرض این که داده‌های چنین حس‌گری قبلا دریافت و بر روی رایانه ذخیره شده باشد، در صورتی که در هر ثانیه ۳۶۰ نمونه از رایانه به ESP ارسال کنیم، رفتار یک حس‌گر دیجیتال با نرخ نمونه‌برداری ۳۶۰ را شبیه‌سازی کرده‌ایم.

پیاده‌سازی این بخش به این صورت انجام شد که پایه‌های RX و TX ماژول ESP به پورت سریال یک کامپیوتر وصل شد و داده‌های دیجیتال ضربان قلب که قبلا به وسیله‌ی یک سنسور دیجیتال تولید شده بودند،‌ به وسیله‌ی اسکریپتی در کامپیوتر به ESP ارسال شدند. در هر ثانیه ۳۶۰ مقدار از مقادیر ذخیره شده با نرخ باد ۱۱۲۵۰۰ بیت بر ثانیه به ESP ارسال شدند. ESP این داده‌ها دریافت کرده و پردازش‌های آینده را بر روی آن‌ها انجام خواهد داد. این ماژول به طور دائم در حال اجرای الگوریتم تشخیص QRS بر روی داده‌هایی که قبلا دریافت کرده است می‌باشد، و در این حین داده‌های جدیدی نیز از سمت رایانه (حس‌گر) دریافت می‌کند.
\subsubsection{اعمال الگوریتم و فرستادن شماره‌ی نمونه به  سرور
 در صورت تشخیص قله}
	 هدف این بخش این است که  ماژول \lr{ESP8266} الگوریتم تشخیص QRS را بر روی نمونه‌هایی که دریافت می‌کند اجرا کرده و در صورت تشخیص قله، موقعیت زمانی آن را برای سرور بفرستد. در همین حین، هر لحظه نمونه‌های جدیدی از طریق ارتباط سریال دریافت می‌شوند. چالش به‌وجودآمده در این مرحله این است که این نمونه‌های جدید نباید از دست بروند. یک راه حل ممکن برای این موضوع،‌ پیاده‌سازی نوعی مکانیزم چندنخی\LTRfootnote{Multithreading} در \lr{ESP8266} است. در یکی از نخ‌ها، داده‌های جدید دریافت شوند و در نخ دیگر الگوریتم بر روی داده‌‌های موجود اجرا شود.
	 
با بررسی‌های انجام‌شده دریافت شد که پیاده‌سازی چندنخی بر روی \lr{ESP8266} پیچیدگی بالایی داشته و کارا نمی‌باشد. به جای پیاده‌سازی این روش، از امکان ایجاد وقفه‌ی سریال در هنگام دریافت داده استفاده شد. \lr{ESP8266} امکان دریافت داده‌ها به صورت مبتنی بر وقفه را دارد، که در کتاب‌خانه‌ی \lr{HardwareSerial} به طور کامل پیاده‌سازی شده است. نحوه‌ی پیاده‌سازی به این شکل است که به محض ورود داده‌ی سریال جدید، \lr{ESP8266} کار خود را رها کرده و به وقفه سرویس می‌دهد. در روتین وقفه، کاراکتر تازه وارد از طریق ارتباط سریال، در بافر سریال \lr{ESP8266} می‌شود. سپس برنامه از روتین وقفه خارج شده و به ادامه‌ی کار خود باز می‌گردد. با استفاده از این امکان \lr{ESP8266} قادر است به طور همزمان با اجرای الگوریتم، نمونه‌های جدید را دریافت کند. به دلیل محدود بودن حجم بافر سریال داخلی موجود در \lr{ESP8266}، نیاز به پیاده‌سازی یک مکانیزم بافرینگ در خود کد نیز وجود دارد. برای جلوگیری از سرریز کردن بافر سریال، در ابتدای هر لوپ اجرای برنامه‌ی \lr{ESP8266} به این بافر سرکشی شده و داده‌های جدید را از آن بر می‌داریم و در بافری که خود پیاده‌سازی کرده‌ایم قرار می‌دهیم. این بافر برای اطمینان حجم بیشتری دارد و با استفاده از آرایه پیاده‌سازی شده‌است. داده‌های جدید در این آرایه می‌مانند، تا وقتی که نوبت پردازش و انجام الگوریتم روی آن‌ها فرا برسد. در این جا از \lr{Thingspeak API} به عنوان فضایی برای ذخیره‌ی این داده‌ها استفاده شد.
	

\section{عملیات پردازش سمت سرور}

	\subsection{نحوه‌ی دریافت داده‌های پیش‌پردازش شده در سرور}
	در کد سمت سرور،‌ داده‌ها از \lr{Thingspeak API} به صورت بی‌درنگ دریافت می‌شوند. در این جا منظور از بی‌درنگ بودن این است که برنامه‌ی سمت سرور دائما در یک حلقه به \lr{API} درخواست داده و داده‌هایی که در فاصله‌ی این درخواست و درخواست قبلی در سرور ثبت شده‌اند را دریافت می‌کند. همان‌طور که اشاره شد، هر کدام از این داده‌ها شماره‌ی نمونه‌ی یک قله‌ی \lr{R} هستند. داده‌هایی که در هر نوبت خواندن از \lr{API} دریافت شده‌اند، در یک آرایه ذخیره می‌شوند. سپس عملیات استخراج ویژگی‌ها روی هر یک از این داد‌ه‌ها اجرا می‌شود تا ویژگی‌های هر داده برای ورود به مدل \lr{SVM} و انجام عملیات دسته‌بندی آماده شود.


	\subsection{داده‌های مورد بررسی در الگوریتم یادگیری}

		\subsubsection{پایگاه داده‌ی MIT-BIH}

		\subsubsection{نحوه‌ی تقسیم داده‌ها به دو مجموعه‌ی آموزش و تست}

	\subsection{نحوه‌ی اجرای الگوریتم یادگیری}
		
		\subsubsection{استخراج ویژگی‌ها}
		
		\subsubsection{پارامترهای به کار گرفته‌شده در الگوریتم}
		
		\subsubsection{استراتژی رای‌دهی}

	\subsection{ارزیابی نتایج حاصل از یادگیری}
	
		\subsubsection{معیارهای کارایی}

%------------------------ End chapter 3 -------------
